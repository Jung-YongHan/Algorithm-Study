## BOJ 1436 영화감독 숌
#### *문제 접근 전략
두가지 풀이로 나뉠 것 같다. 메모리를 써서 입력에 대해 바로 답을 낼 것인지,  
입력마다 코드 실행 후 답을 낼 것인지.

##### 첫번째 풀이 - 정답
해당 풀이에는 단점이 존재한다.  
수가 커질 수록 메모리 사용량은 증가하는 것,  
그것대로 최적화 하기위해서 임의의 정수를 range함수 안에 넣지 못한다는 것.  
```python 
n = int(input())
arr = []
for i in range(666, int(3e6)):
    if '666' in str(i):
        arr.append(str(i))
print(arr[n-1])
```
##### 두번째 풀이 - 정답
가장 단순한 브르투포스 풀이이다.  
위 코드와 논리적으론 거의 비슷하며 수를 1씩 증가시켜가면서  
666이 들어있는 수가 나왔을 시 카운트를 1 증가시켜주었다.  
메모리를 적게 사용한다는 것이 장점이다.
```python
n = int(input())
result = 666
cnt = 0
while True:
    if '666' in str(result):
        cnt += 1
    if cnt == n:
        break
    result+=1
print(result)
```

#### 개선할 점 & 얻은 점
실제 시스템에 적용했을 때를 기준으로 보았을 때는 첫번째 알고리즘이 더 나은 것 같다.  
서버가 존재하는 한 메모리에 큰 부담은 없을 것이고 사용자의 입력에 대해 빠른 출력값이  
나와야 하므로 계산을 매번 수행해야 하는 두번째 알고리즘 보다는 낫다고 생각한다.