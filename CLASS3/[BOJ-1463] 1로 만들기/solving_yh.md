## BOJ 1463 1로 만들기
#### 문제 접근 전략
한 숫자의 1로 만드는 최솟 값은 정해져 있고  
3으로 나눈 수, 2로 나눈 수, 1을 뺀 수 중 최솟값에서 1을 더하는 결과.  
즉, 점화식을 이용하여 풀 수 있는 문제이다.
##### 첫번째 풀이 - 정답
연산의 중복을 줄이고자 반복문 마지막에 1을 더해주었고,  
6의 배수가 있을 수 있으니 if문을 두 번 작성하였다.
```python
n = int(input())
dp = [0]*(n+1)
for i in range(2, n+1):
    dp[i] = dp[i-1]
    if i % 2 == 0:
        dp[i] = min(dp[i//2], dp[i])
    if i % 3 == 0:
        dp[i] = min(dp[i//3], dp[i])
    dp[i] += 1
print(dp[n])
```
##### 두번째 풀이 - 6달 전
정석풀이였어서 그런지 코드에서 별로 차이가 없었다.  
```python
n = int(input())
dp = [0 for _ in range(n+1)]
for i in range(2, n+1):
    dp[i] = dp[i - 1] + 1
    if i % 3 == 0:
        dp[i] = min(dp[i//3] + 1, dp[i])
    if i % 2 == 0:
        dp[i] = min(dp[i//2] + 1, dp[i])
print(dp[n])
```

#### 개선할 점 & 얻은 점
소요 시간 측면에서는 리스트 컴프리헨션이 조금 더 빠른 성능을 보였지만 간소한 차이었다. 메모리 측면에서는 리스트 컴프리헨션이 더 높은 것을 보였다. 그리고 연산 중복을 줄이기 위해서 마지막에 1을 더한 코드가 시간이 조금 더 걸렸다. 이유는.. 잘 모르겠다. 아마 dp값에 접근하고 그 dp값에 1은 더해준다는 것이 시간이 오래걸리는 것인가..