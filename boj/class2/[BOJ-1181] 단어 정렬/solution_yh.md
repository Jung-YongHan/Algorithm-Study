## BOJ 1181 단어 정렬

#### *문제 접근 전략
문제의 조건에 따라 입력 원소들을 정렬하는 전형적인 정렬문제.  
python은 람다함수를 이용하여 쉽게 정렬.  
그러나 스킬, 문법부족(아니면 존재하지 않는 문법이거나)으로 기본적인 정렬만 수행.  
해당 문제는 숫자 정렬이 아닌 알파벳 단어 정렬이므로 각 단어의 알파벳들을 나누어 실행해주었음.


##### 첫번째 풀이 - 정답
코드는 생각하면서 짜서 시간이 꽤 걸렸다.  
중복 단어는 생략하기 때문에 set객체를 사용해주었다.  

단어를 분해하여 아스키코드로 변환하는 작업은 어렵지 않게 구현하였음.  
그러나 다시 단어로 조합하는 과정상 번거러움이 되게 많았었는데 그것을 아스키코드 상의 위치로 해결하였음.  

해당 풀이 중 핵심은 아스키코드 상 소문자 알파벳은 97부터 시작하는 것인데,  
단어 내에 알파벳 a, b, c는 아스키코드 두 자릿수로 조합 과정에서 중간에 여러번 나타날 시 번거러움이 있었음.  

그렇다면 아스키코드로 변환 후 3을 더해준다면 모든 소문자 알파벳들은 세 자릿수로 되는 것이기에  
분해 시 3을 더해주고 조합 시 3을 빼주어 원본 단어를 유지하게 해주었음.

```python
import sys
input = sys.stdin.readline

arr = set() # unique화
for i in range(int(input())):
    arr.add(input())

arr = list(arr)
t = len(arr)

for i in range(t):  # 각 알파벳들을 아스키코드로 변환하여 합쳐주는 작업
    tmp1 = list(arr[i])
    tmp2 = []
    for j in range(len(tmp1)):
        tmp2.append(str(ord(tmp1[j])+3))
    arr[i] = "".join(tmp2)

arr.sort(key=lambda x:(len(x), int(x))) # 길이, 크기대로 정렬 수행

for i in range(t):  # 아스키코드를 다시 알파벳으로 바꾸어 주는 작업
    tmp = []
    val = arr[i]
    for j in range(len(val)//3):
        num = int(val[j*3:j*3+3])
        tmp.append(chr(num-3)) 
    print("".join(tmp))
```

##### 두번째 풀이 - 다른 사람 코드 참고
문법의 중요성을 깨달은 문제이다.  
파이썬은 숫자, 문자, 문자열 전부 상관없이 오름차순 정렬을 지원한다.  
대소문자가 섞여있는 데이터의 경우 대문자 오름차순 > 소문자 오름차순으로 정렬된다.(문자를 아스키코드 값에 대응하기 때문)  

그렇기 때문에 사전순으로 먼저 정렬을 해준 후에 길이에 따른 정렬을 해주었다.  
아스키코드 값을 이용하여 알고리즘이 작동된다는 점에서 유사하였다는 의의를 갖고 가면 될 것 같다.
```python
import sys

arr = set()
for i in range(int(input())):
    arr.add(sys.stdin.readline().rstrip())
arr = list(arr)

arr.sort()
arr.sort(key=len)
# arr.sort(key=lambda x:(len(x), x)) 더 쉬운 방법이지만 저지 기준 더 느린 결과로 나옴

for s in arr:
    print(s)
```

#### 개선할 점 & 얻은 점
어떤 언어이든 문법 공부를 소홀히 하면 안 될 것 같다고 느꼈다.  
파이썬 문법에 자신 있다고 했지만 가장 기본적인 정렬 문법 조차 이해도가 부족해  
직접 구현을 해버렸다. 물론 구현하면서 얻은 점도 많았지만,  
실제 코테였을 경우 알고리즘 짜다가 시간을 다 소모했을 것이다.  
파이썬의 강력함을 상기하게 해준 문제이다.